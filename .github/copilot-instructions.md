<!-- GitHub Copilot instructions for AI coding agents working on this repo -->

# Quick Orientation

- **Project type:** Flutter app with a small Python-based model service in `functions/`.
- **UI / app code:** `lib/` — core logic under `lib/core/`, screens under `lib/presentation/`.
- **Backend model service:** `functions/main.py` (FastAPI) which loads joblib model artifacts from Firebase Storage or local files.

**Why this structure:** The mobile app uses Firebase for auth/storage and calls a separate model service for heavy ML work. Keeping models in `functions/` avoids bundling large artifacts into the mobile build.

**Key files/dirs:**
- `pubspec.yaml`: dependencies (Riverpod, go_router, Firebase libs).
- `lib/core/api/`, `lib/core/repositories/`: API clients and data layer.
- `lib/core/providers/`: Riverpod providers — check these for how state is exposed.
- `lib/presentation/`: feature UI folders (auth, chat, home, tasks, journal).
- `lib/firebase_options.dart`: Firebase config generated by FlutterFire.
- `functions/README.md` and `functions/main.py`: local dev & deployment for the model service.

## Developer Workflows (project-specific)

- Install Flutter packages: `flutter pub get` at repo root.
- Run app locally (desktop): `flutter run -d windows` (or choose mobile device/emulator).
- Run unit/widget tests: `flutter test`.
- Android builds (Windows PowerShell):
  ```powershell
  cd android; .\gradlew.bat assembleDebug; cd ..
  ```
- Functions local dev (PowerShell):
  ```powershell
  # run from repo root or functions/
  C:/Users/vince/AppData/Local/Python/pythoncore-3.11-64/python.exe -m uvicorn functions.main:app --reload --port 8080
  ```
- Functions with Docker (from `functions/`):
  ```powershell
  docker build -t model-service:local .
  docker run --rm -p 8080:8080 --env-file .env model-service:local
  ```

## Patterns & Conventions to Follow

- State management: `flutter_riverpod` is used across `lib/core/providers/`. Prefer creating providers for shared state and expose read/watch patterns consistent with existing files.
- Routing: uses `go_router` — look for router setup under `lib/core/routing/` and add routes there rather than scattering route definitions.
- Data layer: API clients live in `lib/core/api/` and repositories in `lib/core/repositories/`. New features should add an API client + repository + provider pattern.
- Assets: images and icons are under `assets/images/` and `assets/icons/`. The splash config is set in `pubspec.yaml` under `flutter_native_splash` — update there when changing splash assets.
- Model artifacts: `functions/` stores `.joblib` and vectorizers; the service lazy-downloads from Firebase Storage if not found locally. For local dev set `LOCAL_MODEL_PATH` and `LOCAL_VECTORIZER_PATH` in `.env`.

## Integration Points & External Dependencies

- Firebase: Auth, Firestore, Storage and Functions. See `pubspec.yaml` and `lib/firebase_options.dart`.
- External model service: the mobile app interacts with the FastAPI service in `functions/` (endpoint `/chat`). Keep the service URL configurable for dev vs prod.
- Google/Gemini API keys: stored in env (see `functions/.env` usage). Do NOT commit secrets.

## Helpful Examples (search these when implementing changes)

- Follow provider examples in `lib/core/providers/` for exposing state to UI.
- For new screens, mirror structure from `lib/presentation/auth/` and `lib/presentation/chat/`.
- For API calls, look at `lib/core/api/` and how repositories wrap them under `lib/core/repositories/`.

## Editing / Testing Notes for AI Agents

- When changing Flutter code, run `flutter analyze` and `flutter test` where possible.
- If modifying the model service, run the FastAPI server locally and use the PowerShell `Invoke-RestMethod` example in `functions/README.md` to verify endpoints.
- Keep edits minimal and consistent: add new providers/routes in the canonical directories mentioned above.

---
If a section is unclear or you want more examples (e.g., provider + widget example), tell me which area and I'll expand the file. 
